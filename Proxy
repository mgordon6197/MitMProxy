import socket
import re
from concurrent.futures import ThreadPoolExecutor
from urllib.parse import urlparse
import logging
import ssl

SOCKET_READ_SIZE = 4096
MAX_WORKER_SIZE = 20
HOST = b'yelp.com'
CERTIFICATE = 'yelp_cert.crt'
PRIVATE_KEY = 'private_key.key'


def main():
    logging.basicConfig(filename='HTTP_Proxy.log', format='%(asctime)s %(levelname)-8s %(message)s',
                        datefmt='%m-%d %H:%M', filemode='w', level=logging.DEBUG)
    console = logging.StreamHandler()
    console.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(levelname)-8s %(message)s')
    console.setFormatter(formatter)
    logging.getLogger('').addHandler(console)

    server_listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_listener.bind(('', 50000))
    # become a server socket
    server_listener.listen(5)
    logging.debug(server_listener.getsockname()[1])

    with ThreadPoolExecutor(max_workers=MAX_WORKER_SIZE) as executioner:
        while 1:
            client_to_me_socket, address = server_listener.accept()
            client_request = non_blocking_receive(client_to_me_socket)
            connect_pattern = b'CONNECT'
            is_connect_request = re.search(connect_pattern, client_request)
            if is_connect_request is None:
                executioner.submit(http_threaded_request, client_to_me_socket, client_request)
            else:
                is_correct_host = re.search(HOST, client_request)
                if is_correct_host is not None:
                    client_socket, server_socket = set_up_ssl_connection(client_to_me_socket, client_request)
                    executioner.submit(https_threaded_request, client_socket, server_socket)


def non_blocking_receive(read_socket):
        read_socket.setblocking(0)
        read_socket.settimeout(.3)
        data = b''
        while 1:
            try:
                new_data = read_socket.recv(SOCKET_READ_SIZE)
                data = data + new_data
                if new_data == b'' or data[-4:] == b'\r\n\r\n':
                    break
            except socket.error as e:
                logging.error(str(e))
                break
            except socket.timeout:
                break
        return data


def set_up_ssl_connection(client_to_me_socket, client_request):
    host_pattern = b'CONNECT (.*) HTTP'
    host = re.search(host_pattern, client_request)
    client_connstream = None
    server_connstream = None
    if host is not None:
        url = host.group(1)
        url_parse = urlparse(b'http://' + url)
        port = 443
        if url_parse.port is None:
            port = url_parse.port

        server_context = ssl.create_default_context()
        sock = socket.socket(socket.AF_INET)
        try:
            server_connstream = server_context.wrap_socket(sock, server_hostname=url_parse.hostname.decode())
        except socket.timeout as e:
            logging.error(e)
            return None, None

        server_connstream.connect((url_parse.hostname, port))
        cert = server_connstream.getpeercert()
        logging.debug(cert)

        client_to_me_socket.sendall(b'HTTP/1.1 200 OK\r\n\r\n')
        client_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
        client_context.load_cert_chain(certfile=CERTIFICATE, keyfile=PRIVATE_KEY)
        try:
            client_connstream = client_context.wrap_socket(client_to_me_socket, server_side=True)
        except socket.timeout as e:
            logging.error(e)
            return None, None

    return client_connstream, server_connstream


def http_threaded_request(client_to_me_socket, request):
    client_data = request
    logging.info(b'FROM CLIENT: ' + client_data)

    get_pattern = b'GET (.*) HTTP'
    matched_host = re.search(get_pattern, client_data)
    if matched_host is None:
        post_pattern = b'POST (.*) HTTP'
        matched_host = re.search(post_pattern, client_data)
        if matched_host is None:
            logging.info(b'Neither POST or GET: ' + client_data)
            client_to_me_socket.close()
            return

    url = matched_host.group(1)
    urlParse = urlparse(url)

    me_to_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    me_to_server_socket.connect((urlParse.hostname, 80))

    me_to_server_socket.sendall(client_data)
    server_data = non_blocking_receive(me_to_server_socket)
    logging.info(b'FROM SERVER: ' + server_data)
    client_to_me_socket.sendall(server_data)

    client_to_me_socket.close()
    me_to_server_socket.close()


def https_threaded_request(client_to_me_socket, possible_me_to_server_socket):
    client_data = non_blocking_receive(client_to_me_socket)
    logging.info(b'FROM CLIENT: ' + client_data)

    get_pattern = b'GET (.*) HTTP'
    matched_host = re.search(get_pattern, client_data)
    if matched_host is None:
        post_pattern = b'POST (.*) HTTP'
        matched_host = re.search(post_pattern, client_data)
        if matched_host is None:
            post_pattern = b'GET'
            matched_host = re.search(post_pattern, client_data)
            if matched_host is None:
                post_pattern = b'POST'
                matched_host = re.search(post_pattern, client_data)
                if matched_host is None:
                    logging.info(b'Neither POST or GET: ' + client_data)
                    return

    me_to_server_socket = possible_me_to_server_socket
    me_to_server_socket.sendall(client_data)
    server_data = me_to_server_socket.recv(SOCKET_READ_SIZE)
    logging.info(b'FROM SERVER: ' + server_data)
    client_to_me_socket.sendall(server_data)

    client_to_me_socket.close()
    me_to_server_socket.close()

if __name__ == "__main__":
    main()