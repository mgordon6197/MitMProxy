import socket
import re
from concurrent.futures import ThreadPoolExecutor
from urllib.parse import urlparse
import logging
import ssl

SOCKET_READ_SIZE = 4096
MAX_WORKER_SIZE = 20
HOST = b'yelp.com'
CERTIFICATE = 'servercert.pem'
PRIVATE_KEY = 'serverkey.pem'


def main():
    logging.basicConfig(filename='HTTP_Proxy.log', format='%(asctime)s %(levelname)-8s %(message)s',
                        datefmt='%m-%d %H:%M', filemode='w', level=logging.DEBUG)
    console = logging.StreamHandler()
    console.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(levelname)-8s %(message)s')
    console.setFormatter(formatter)
    logging.getLogger('').addHandler(console)

    server_listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_listener.bind(('', 50000))
    # become a server socket
    server_listener.listen(5)
    logging.debug(server_listener.getsockname()[1])

    with ThreadPoolExecutor(max_workers=MAX_WORKER_SIZE) as executioner:
        while 1:
            client_to_me_socket, address = server_listener.accept()
            client_request = non_blocking_receive(client_to_me_socket)
            connect_pattern = b'CONNECT'
            is_connect_request = re.search(connect_pattern, client_request)
            if is_connect_request is None:
                executioner.submit(http_threaded_request, client_to_me_socket, client_request)
            else:
                # is_correct_host = re.search(HOST, client_request)
                # if is_correct_host is not None:
                #     logging.debug(b'Correct Host:')
                executioner.submit(set_up_ssl_connection, client_to_me_socket, client_request)


def non_blocking_receive(read_socket):
        read_socket.setblocking(0)
        read_socket.settimeout(2)
        data = b''
        while 1:
            try:
                new_data = read_socket.recv(SOCKET_READ_SIZE)
                data = data + new_data
                if new_data == b'' or data[-4:] == b'\r\n\r\n':
                    break
            except socket.error as e:
                logging.error('non blocking read: ' + str(e))
                break
        return data


def set_up_ssl_connection(client_to_me_socket, client_request):
    logging.info(client_request)
    host_pattern = b'CONNECT (.*) HTTP'
    host = re.search(host_pattern, client_request)
    client_connstream = None
    server_connstream = None
    if host is not None:
        url = host.group(1)
        url_parse = urlparse(b'http://' + url)
        port = 443
        if url_parse.port is None:
            port = url_parse.port

        server_context = ssl.create_default_context()
        sock = socket.socket(socket.AF_INET)
        try:
            server_connstream = server_context.wrap_socket(sock, server_hostname=url_parse.hostname.decode())
        except socket.timeout as e:
            logging.error(b'server connection failed: ' + e)
            return
        server_connstream.connect((url_parse.hostname, port))

        cert = server_connstream.getpeercert()
        logging.debug(cert)
        common_name, dns_list = parse_cert(cert)
        # certificate, private_key = create_cert_and_key(common_name, dns_list)

        client_to_me_socket.sendall(b'HTTP/1.1 200 OK\r\n\r\n')
        client_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
        client_context.load_cert_chain(certfile=CERTIFICATE, keyfile=PRIVATE_KEY)
        try:
            client_connstream = client_context.wrap_socket(client_to_me_socket, server_side=True)
        except socket.timeout as e:
            logging.error(b'client connection failed: ' + e)
            return

    if client_connstream is None or server_connstream is None:
        return
    else:
        https_threaded_request(client_connstream, server_connstream)


def http_threaded_request(client_to_me_socket, request):
    client_data = request
    logging.info(b'FROM CLIENT: ' + client_data)

    get_pattern = b'GET (.*) HTTP'
    matched_host = re.search(get_pattern, client_data)
    if matched_host is None:
        post_pattern = b'POST (.*) HTTP'
        matched_host = re.search(post_pattern, client_data)
        if matched_host is None:
            # logging.info(b'Neither POST or GET: ' + client_data)
            client_to_me_socket.close()
            return

    url = matched_host.group(1)
    urlParse = urlparse(url)

    me_to_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    me_to_server_socket.connect((urlParse.hostname, 80))

    me_to_server_socket.sendall(client_data)
    server_data = non_blocking_receive(me_to_server_socket)
    logging.info(b'FROM SERVER: ' + server_data)
    client_to_me_socket.sendall(server_data)

    client_to_me_socket.close()
    me_to_server_socket.close()


def https_threaded_request(client_to_me_socket, me_to_server_socket):
    client_data = non_blocking_receive(client_to_me_socket)

    # get_pattern = b'GET (.*) HTTP'
    # matched_host = re.search(get_pattern, client_data)
    # if matched_host is None:
    #     post_pattern = b'POST (.*) HTTP'
    #     matched_host = re.search(post_pattern, client_data)
    #     if matched_host is None:
    post_pattern = b'GET'
    matched_host = re.search(post_pattern, client_data)
    if matched_host is None:
        post_pattern = b'POST'
        matched_host = re.search(post_pattern, client_data)
        if matched_host is None:
            # logging.info(b'Neither POST or GET: ' + client_data)
            client_to_me_socket.close()
            return

    me_to_server_socket = me_to_server_socket
    me_to_server_socket.sendall(client_data)
    server_data = non_blocking_receive(me_to_server_socket)
    client_to_me_socket.sendall(server_data)

    logging.info( b'FROM CLIENT: ' + client_data)
    logging.info( b'FROM SERVER: ' + server_data)

    client_to_me_socket.close()
    me_to_server_socket.close()


def parse_cert(cert):
    dns_pattern = 'DNS\', \'(.+?)\'+?'
    common_name_pattern = 'commonName\', \'(.*)\''

    common_name = re.search(common_name_pattern, str(cert['subject']))
    print('common_name: ' + common_name.group(1))
    dns_list = re.findall(dns_pattern, str(cert['subjectAltName']))
    print('alt_names:\n')
    for x in dns_list:
        print(x)

    return common_name, dns_list


if __name__ == "__main__":
    main()